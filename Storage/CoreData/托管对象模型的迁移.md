# 托管对象迁移（数据库升级）
本章就来介绍如何添加模型版本及模型映射，同时也会演示几种不同的迁移技术，供你在升级模型时选用。

## 模型版本控制
在应用程序的进化过程中，其托管对象模型也可能需要改变。对于一些比较简单的修改，诸如设定属性的默认值、设定验证规则、使用获取请求模板等，是可以直接实施的。而对于另外一些更为结构化的（structural）修改，则需先把持久化存储区迁移到新的模型版本才行。假如没有提供迁移数据所需的映射与设定，那么应用程序就会崩溃。

### 添加现版本模型
* 选中xxx.xcdatamodeld文件，Editor -> Add Model Version -> 填写Version name并选择Based on model -> Finish
* 设置新创建的版本模型为当前版本。选中xxx.xcdatamodeld文件 -> Show the File inspector -> Core Data Model  -> Model Version -> Current选择创建的新版本模型

### 轻量级的迁移方式
把新模型设为当前版本之后，必须迁移现有的持久化存储区，只有这样，才能正常使用新模型。这是因为，持久化存储区协调器会试着用新版的模型来打开原有的存储区，但由于原有的存储区是用旧版模型创建的，所以该操作会失败。。在向NSPersistentStoreCoordinator添加存储区的时候，只需将下列选项放在NSDictionary里传过去，即可自动完成存储区的迁移工作：
* 如果传给NSPersistentStoreCoordinator的NSMigratePersistentStores-Automatically-Option是YES，那么Core Data就会试着把低版本的（也就是与当前模型不兼容的）持久化存储区迁移到最新版本的模型。
* 如果传给NSPersistentStoreCoordinator的NSInferMappingModelAutomaticallyOption是YES，那么Core Data就会试着以最为合理的方式自动推断出源模型实体（source model entity）中的某个属性到底对应于“目标模型实体”（destination model entity）中的哪一个属性。


```
  NSDictionary *options = @{
                              NSMigratePersistentStoresAutomaticallyOption:@YES,
                              NSInferMappingModelAutomaticallyOption:@YES,
                              NSSQLitePragmasOption: @{@"journal_mode": @"DELETE"}};
  NSError *error = nil;
  NSPersistentStore *store = [NSPersistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType
                                                                          configuration:nil
                                                                                    URL:[self storeURL]
                                                                                options:options
                                                                                  error:&error];
```


把上述两个选项都打开并传给NSPersis-tentStoreCoordinator，这种迁移方式就叫做轻量级迁移（lightweight migration）

