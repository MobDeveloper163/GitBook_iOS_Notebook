# Messaging

这一章描述消息描述是怎样转换成obj\_msgSend函数调用的以及怎样按名称引用方法。这章也解释了怎样充分利用obj\_msgSend,以及在需要时，怎样绕过动态绑定。

## obj\_msgSend函数

在OC中，直到消息时消息才会和方法绑定。编译器将消息描述

```
[receiver message]
```

转换成消息函数的调用，objc\_msgSend.这个函数携带receiver的和在消息中提到的方法的名字—也就是方法selector—作为两个重要的参数：

```
objc_msgSend(receiver, selector)
```

任何传递到这个message中的参数也都回被objc\_msgSend处理:

```
objc_msgSend(receiver, selector, arg1, arg2, ...)
```

消息函数处理动态绑定所需的所有的事情：

* 它首先找到selector引用的程序（方法实现）。由于相同的方法在单独的类里可以有不同的实现，依赖receiver类精确的找到程序。
* 然后它调用这个程序，把它传给receiving对象（它的数据的指针），和方法指定的任意参数一起。
* 最终它传递程序的返回值作为自己的返回值

> 注意：编译器生成消息函数的调用。绝对不要在自己写的代码中直接调用消息函数。

消息的键躺在编译器为每一个类和对象建立的结构。每一个类包含这两个必要的元素：

* 指向分类的指针
* 类分发表（class dispatch table）。分发表有把方法选择器（method selector）和由类指定的方法的地址关联的入口。setOrigin::方法的selector和）setOrigin::（实现的程序）的地址先关联。display方法的selector和display的地址相关联，等等。

当一个对象创建时，会给它内存空间，也会初始化它的实例变量。对象变量中的第一个是类结构的一个指针。在结构体定义的任意的字段，一个对象需要和objc\_object结构体（在objc\/objc.h中定义的）等价。然而你很少需要创建自己的根对象，对象继承自NSObject和NSProxy必然拥有一个isa变量。

类的元素和对象结构在下图说明：

![](/assets/runtime-001.png)

当一个消息发送给对象时，消息函数跟随isa指针到类结构（class structure）,在类分发表中查找方法选择器。如果找不到，objc\_msgSend沿着指针到superclass，并且尝试在superclass的分发表中查找。查找不断失败的过程中，objc\_msgSend攀登类层级，直到NSObject类。一旦定位到这个方法选择器，消息函数调用分发表中的方法，并把接收到的对象的的数据结构传递给它。



这就是在运行时里方法实现选择的方式—或者，用面向对象变成的术语老说，方法和消息动态动态绑定。



运行时系统在使用方法时，通过缓存方法的选择器和地址来加速消息执行。每个类都有单独的缓存，它能包含被继承的方法和类定义方法的选择器。在查找分发表之前，消息常规先接收到的对象的类缓存（理论上讲，一个方法一旦被使用，就可能会被再此使用）。如果方法选择器在缓存中，消息会比函数调用有稍稍的慢一些。如果一个程序运行了足够长的时间“暖场”它的缓存，程序发送的大部分的消息都能命中它的缓存。在程序运行的时候，缓存动态的增加来容纳新的消息。

















