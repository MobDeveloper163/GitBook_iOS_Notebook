## 消息转发

发送消息到一个对象，对象不处理这个消息是错误的。然而，在通报这个错误前，运行时系统给了接收对象第二次机会处理这个消息。

## 转发

如果向一个对象发送消息，但是对象不处理这个消息，在通报这个错误前，运行时发送forwardInvocation:消息给这个对象，并把NSInvocation对象作为唯一的参数传递。这个NSInvocation对象包含原始消息和通过它传递的参数。

你可以实现forwardInvocation:方法给这个消息一个默认的回应，或者避免错误的其他方式。顾名思义，forwardInvocation:通常用于将消息转发给另一个对象。

想要查看转发的范围和意图，想象以下场景：首先，假设你正在设计一个对象能够响应一个叫做negitiate的消息，并且你希望对象的响应包含另一种对象的响应。你可以通过传递一个negotiate消息到这个对象中你实现的negotiate方法的方法体的某个地方非常容易的实现。

更进一步，假设你想让你的对象对negotiate消息的响应完全是成为另一个类里面实现的响应。实现的一种方式是创建你的类从其他类继承这个方法。然而，也可能用这种方式达成。为什么你的类以及实现negotiate的类在继承层级的不同分支，可能有合理的原因。

```
-(id)negotiate{
    if(someOtherObject respondsTo@selector(negotiate)){
        return [someOtherObject negotiate];
    }
    return self;
}
```



这种处理事情的方式可能有一点笨拙，如果你的对象有多个消息想要传递给其他对象。你必须写一个方法去覆盖每一个你想要从其他类借来的方法。此外，你不可能处理你不知道的情况，在你下代码的时候，你可能想要转发一组完整的消息。这组消息或许依赖运行时的事件，在将来当新方法和类被实现时，这组消息也可能改变。



forwardInvocation:消息提供的第二次机会为这个问题提供了不太特别的解决方案，是动态的，不是静态的。它像这样工作：当一个对象因为没有一个方法匹配消息中的选择器而不能响应消息时，运行时系统通过发送forwardInvocation:消息通知对象。每一个对象都从NSObject类继承了forwardInvocation:方法。然而，这个方法的NSObject版本简单的调用doesNotRecognizeSelector:。重写NSObject版本并自实现，你能够充分利用forwardIncocation:提供的机会转发其他对象的消息。



先要转发一个消息,forwardInvocation:要做的所有的事情如下：

* 检测消息要到哪里去
* 和原始参数一起，把消息发送到那里去


消息可以用invokeWithTarget:方法发送

```
-(void)forwardInvocation:(NSInvocation *)anInvocation{
  if([someOtherObject respondsToSelector:[anInvocation selector]]){
    [anInvocation invokeWithTarget:someOtherObject];
  }else{
    [super forwardInvocation:anInvocation];
  }
}  
```

被转发的消息的返回值被返回给原始的发送者。所有类型返回值，包括id、结构体和双精度浮点数，都可以分发给发送者。



一个forwardInvocation:方法可以为未识别的消息扮演分发中心，把消息分发到不同的接收者。或者可以是一个转移站，把所有的消息发送到同一个目的地。它可以把一个消息转换成另一个，或者简单的吞掉一些消息，从而没有回应或者错误。同时forwardInvocation:能够合并一些消息。forwardInvocation:能够做什么取决于实现者。然而它在转发链中为链接对象提供的机会为编程设计打开了可能性。

> 注意：forwardInvocation:仅仅在名义上的接收者不调用存在的方法是才会处理消息。比如，如果你想要你的对象转发negotiate消息到另一个对象时，这个对象本身不能有negotiate方法。如果这个对象有，这个消息永远不会到达forwardInvocation:



参考Foundation framework reference 中NSInvocation类的明确说明以获取更多关于转发和invocations的信息。



### 转发和多继承

转发模仿继承，并且能够用来为OC程序增添多重继承的效果。

像下图展示的，一个通过转发响应消息的对象似乎借用和继承在另一个类中定义的方法的实现。

![](/assets/runtime_forwarding_001.png)

在这副插图中，Warrior类的实例转发了negotiate的消息给Diplomat类的一个实例。这个Warrior像一个Diplomat,似乎在negotiate。Warrior仿佛要响应这个消息，并且因为实际目的它确实响应了（尽管是Diplomat真正做了这个工作）。



转发消息的对象从继承层级的两个分支“继承”方法，转发对象自身的分支以及响应消息的分支。在上面的例子中，它看起来像继承自Diplomat类和自己的父类。



转发提供了你想从多重继承得到的所有的大部分功能。然而，它们两者之间有这非常重要的不同：多重继承实在单个对象中结合不同的能力。它倾向于大的、多面的对象。另一方面，转发给截然不同的对象分配单独的职责。它把问题分解到不同的小对象中，但是用一种对消息发送者透明的方式把这些对象关联起来。



### 替代对象

转发不仅擅长模仿多继承，同时使得可以开发替代和“覆盖”更实质对象的轻量级对象。替代对象站在另一个对象中并输送消息给另一个对象。











