### 内存管理

#### 程序内存的使用情况

Objective-C可执行程序是由（可执行）代码、初始化和未初始化的程序数据、链接信息、重定位信息、局部数据和动态数据构成的。程序数据包括以静态方式声明的变量和程序常量。

可执行代码、程序数据以及链接和重定位信息会以静态方式分配内存，并在程序周期中一直存在。

局部数据只在语句块中声明并且仅在语句块中有效，当该语句块执行后局部数据不会继续存在。

在运行时Objective-C会创建对象（通过alloc方法）存储在动态分配的内存即堆内存中。

为程序代分配的内存是在编码程序时设置的，，因此占用的是系统内存。一方面，程序的栈内存空间是在程序启动时确定的，会自动由系统管理。另一方面，Objective-C中的对象是在程序运行时动态创建的，不会由系统回收。因此需要程序员管理。不进行内存管理和错误的内存管理会导致以下结果：

* 内存泄漏： 程序没有释放不再使用的对象，就会浪费资源，比如强循环引用，就会出现这种情况。如果系统不断为程序分配内存，但是没有释放，最终会耗尽系统内存。

* 悬挂指针：也叫野指针。如果程序释放了仍在使用的对象，就会导致该问题。如果程序将来尝试访问这些对象，就会出现程序错误。比如对象属性使用assign修饰。

#### MRR
Manual Retain Release,手动保留和释放。使用MRR的基本原则是retain和relaese保持平衡，也就是retain和release成对出现。如果违背了这个原则就会出现内存泄漏和悬挂指针问题。检测这些潜在问题的方式是使用Xcode的Analaze分析工程代码。

#### ARC
Automatic Reference Counting,自动引用计数。自动引用计数工具在编译程序时，编译器会分析源代码，确定以动态方式创建的对象的回收需求，然后在已编译代码的必要位置自动插入retain和release消息。

** ARC的优点：** 可以潜在的提升应用性能和消除内存管理错误（如错误释放仍旧在使用的对象、不留不再使用的对象）。与垃圾回收机制相比，ARC更可靠（保留和释放语句是在编译时插入的），并且不会为实现垃圾回收机制而在程序执行过程中引入暂停操作。但是ARC不会自动处理循环引用问题，需要手动消除循环引用。

#### ARC的生命周期限定符
** __Strong：** 表明任何在使用alloc/init消息创建的对象都会在其作用范围内被保留。等同于MRR中的retain

** __weak: **  表明对象随时可以被释放。只有当对象拥有其他强引用时，weak标记才有用。当对象被释放时，该引用会自动被设为nil。

** __unsafe_unretained: ** 与weak相似，并不会拥有对象，但是在引用的对象销毁时，限定的引用变量不会自动设置为nil。相当于assign






